### 思路：

首先，把$[s]k\{s_1\}k_1\{s_2\}k_2...\{s_n\}k_n,1<=k_1<k_2...<k_n<=k$形式的串成为单串，那么一个合法的串就是若干单串的连接。

令$d_{ij}$表示这段区间压缩后的长度最小值，那么它可能是若干单串（$>=2$个）的连接，也可能是自己本身就是一个单串。

考虑前者，那么直接把区间$i,j$分成左右两个区间的连接即可，$d_{ij}=min(d_{ik}+d_{k+1,j}),k\in[i,j-1]$.

考虑后者：

1. 对于单串中的$s$以及其对应的$k$,一定有$k>=2$.因为$k=1$时，写成单串形式没有分成$s+s_1+s_2..(+表示连接)$优。
2. 一定有$k_n < k$。若相等，则写成单串形式没有分成$[s]k\{s_1\}k_1\{s_2\}k_2...\{s_{n-1}\}k_{n-1}+s_n$优。

在上面条件的约束下，只需在区间$i..j$的首尾找到相等的字串，把它们作为$s$，也有$2*len(s)<=j-i+1$.

假设现在已经确定了$s$，其长度为$len$,那么它的内部怎么分呢？内部有可能有一些字串与$s$相等，该不该把他们列到$k$里面，还是怎么样呢？

用$f[len][i][j]$表示区间$i..j$压缩成单串时，且取用的$s$为$i$开始长为$len$的串时，长度的最小值。

下面枚举内部可能的所有位置$p$，有$p >=i+len,p+len<=j-len+1,且e[len][i][p]=1$,($e[len][i][j]=1$表示从$i$开始长$len$的串和从$j$开始长$len$的串相等)。用$f[len][i][j][p]$表示区间$i..j$压缩成单串时，且取用的$s$为$i$开始长为$len$的串时，且内部$p$起始的串被划到$k$里面，长度的最小值。那么有：$f[len][i][j][p]=f[len][i][p+len-1]+f[len][p][j]-(d[i][i+len-1]+3)$.

- 正向推导：假设$f[len][i][j][p]$已知，也就是存在着单串$[s]k\{s_1\}k_1\{s_2\}k_2...\{s_n\}k_n,len(s)=len$,其长度为$f[len][i][j][p]$,很自然地，可以将它分为在区间$i,p+len-1$,区间$p,j$地两个单串：$str_l=[s]k'\{s_i\}k_i...(k_i<k')$,$str_r=[s]k''\{s_i\}k_i...(k_i>=k')$,且有$k'+k''-1=k$.那么有$f[len][i][p+len-1] <= len(str1)$,$f[len][p][j]<=len(str2)$。假设小于号成立，同样可以构造出一个更小的区间$i,j$上的单串，矛盾，则式子取等。
- 反向推导：假设$f[len][i][p+len-1],f[len][p][j]$已知，由上面的构造法，有$f[len][i][j][p]<=f[len][i][p+len-1]+f[len][p][j]-(d[i][i+len-1]+3)$.假设小于号成立，同样，可以构造出更小的$f[len][i][p+len-1]orf[len][p][j]$,矛盾。

则$f[len][i][j]=min(f[len][i][j][p])$

那么$d[i][j]=min(f[len][i][j])$。

则可以求解。

打印过程也有需要注意的地方，见注释。