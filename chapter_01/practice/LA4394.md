### Proof:

设$str1$与$str2$分别对应着初始和目标串。

对于两个序列$s1[i:j]$与$s2[i:j]$，想要把前者变为后者，$d[i][j]$表示该区间最少变化次数。

1. $s1[i]==s2[i]$

   有$d[i][j]>=d[i-1][j]$，另外，对任意操作序列，使得$s1[i+1:j]==s2[i+1:j]$，都会使得$s1[i:j]==s2[i:j]$，则推得$d[i][j]=d[i+1][j]$.

2. $s1[i]!=s2[j]$

   最好的操作序列一定是：第一步从$i$刷起，到达某个$k,s2[k]=s2[i]$，因为再往右多涂几个格子没有任何意义。然后分成左右两个序列。

   至于为什么要分成左右两个序列：假设有一次操作序列$step$,包含了一个操作，它跨越了左右两个区间，设为$[x,y],x<=k,y>k$

   - 如果它涂的颜色和$s2[i]$不相等，那么必然至少再需要一次操作，使$s2[k]$恢复，那么这并不如把它分成两个操作，$[x:k-1],[k+1:y]$。

   - 如果颜色相等。假设存在$k',k'>y,s2[k']=s2[i]$，那么这次操作，肯定不如：第一步从$i$刷到$k'$,然后以相同的顺序执行$step$中操作。

     如果不存在这个$k'$，那么在右边没有$t,s2[t]=s2[i]$,那么实际上，这个跨越区间的操作在右边的操作是无意义的，可以写为$[x:k]$。

从上面的说明即可写出程序，注意左右是对称的。



如果$str1$是空的(可视为有一种新的底色)，下面证明：如果$str2[i]=str2[j]$,则$d[i][j]=d[i][j-1]=d[i+1][j]$.

由对称性，证明前半部分即可。

首先，$d[i][j]>=d[i][j-1]$.

现在对$i:j-1$的部分进行操作。由上面的论断，最好的操作，其第一步是，从$i$刷到$k$,有$str2[k]=str2[i]$，然后分成左右两部分序列，设对$i:k$的操作是$setpl$，对$k+1:j-1$的操作是$step2$.其中，$step2$操作使得空串变为和$str2$对应部分一样，那么它也能使得底色为$str2[i]$的串变成和$str2$对应部分一样。

那么，我们延长这个第一步操作，直接从$i$刷到$j$.那么我们接着进行$step1,step2$的操作，同样能使$i:j$区间操作成功。

那么得证。

